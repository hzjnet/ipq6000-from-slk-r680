// vim: set et sw=4 sts=4 cindent:
/*
 * @File: estimator.h
 *
 * @Abstract: Public interface for the rate estimator.
 *
 * @Notes:
 *
 * @@-COPYRIGHT-START-@@
 *
 * Copyright (c) 2015-2019 Qualcomm Technologies, Inc.
 *
 * All Rights Reserved.
 * Confidential and Proprietary - Qualcomm Technologies, Inc.
 *
 * 2015-2016 Qualcomm Atheros, Inc.
 *
 * All Rights Reserved.
 * Qualcomm Atheros Confidential and Proprietary.
 *
 * @@-COPYRIGHT-END-@@
 */

#ifndef estimator__h
#define estimator__h

#include "lbd_types.h"  // for LBD_STATUS and other type defs
#include "stadb.h"
#include "steerexec.h"
#include "ieee1905_defs.h"

#if defined(__cplusplus)
extern "C" {
#endif

/**
 * @brief Events generated by this module to signal completion of the
 *        estimation logic.
 */
typedef enum estimator_event_e {
    /// All estimates are available for a single STA are complete.
    estimator_event_staDataMetricsComplete,

    /// All estimates for airtime of STAs on a given channel are complete.
    estimator_event_perSTAAirtimeComplete,

    /// Detected that a STA is suffering from interference
    estimator_event_staInterferenceDetected,

    /// At least one polluted BSS for a STA was marked as no longer polluted.
    estimator_event_staPollutionCleared,

    /// Request Legacy Steering for 11k Max consecutive failed client.
    estimator_event_requestLegacySteering11kSta,

    /// Collection of non serving metrics is complete
    estimator_event_nonServingMetricsComplete,

    /// Collection of STA traffic stats is complete
    estimator_event_staTputEstComplete,

   /// when rcpiType changed from from 0 to 1
    estimator_event_rcpiTypeChanged,

    estimator_event_maxnum
} estimator_event_e;

/**
 * @brief Reason code to indicate why pollution state changed for a given STA
 */
typedef enum estimatorPollutionChangedReason_e {
    /// Pollution state chagned based on detection result.
    estimatorPollutionChangedReason_detection,

    /// Pollution state cleared due to aging.
    estimatorPollutionChangedReason_aging,

    /// Pollution state changed due to report from remote node
    estimatorPollutionChangedReason_remote,

    /// Invalid reason
    estimatorPollutionChangedReason_invalid
} estimatorPollutionChangedReason_e;

/**
 * @brief The format of the estimator_event_staDataMetricsComplete event.
 */
typedef struct estimator_staDataMetricsCompleteEvent_t {
    /// Address of the STA for which capacity and airtime estimates are
    /// complete.
    struct ether_addr addr;

    /// Whether the measurement of STA data metrics succeeded or not.
    LBD_STATUS result;

    /// The trigger to this data metrics estimation
    steerexec_reason_e trigger;

    /// The channel measured in 802.11k beacon report
    lbd_channelId_t measuredChannel;

    /// The freq measured in 802.11k beacon report
    u_int16_t measuredFreq;

    /// The BSS reported in 802.11k beacon report that belongs to the serving AP.
    /// If none, will report an invalid BSS with invalid channel number
    lbd_bssInfo_t measuredServingAPBSS;
} estimator_staDataMetricsCompleteEvent_t;

/**
 * @brief The format of the estimator_event_perSTAAirtimeComplete event.
 */
typedef struct estimator_perSTAAirtimeCompleteEvent_t {
    /// The AP for which STA Airtime measurements were collected for
    lbd_apId_t apId;

    /// The channel on which the estimate is now complete.
    lbd_channelId_t channelId;

    /// The freq on which the estimate is now complete
    u_int16_t freq;

    /// The number of STAs for which an airtime was estimated.
    size_t numSTAsEstimated;
} estimator_perSTAAirtimeCompleteEvent_t;

/**
 * @brief The format of the estimator_event_staInterferenceDetected event.
 */
typedef struct estimator_staInterferenceDetectedEvent_t {
    /// Address of the STA for which interference was detected.
    struct ether_addr addr;
} estimator_staInterferenceDetectedEvent_t;

/**
 * @brief The format of the estimator_event_staPollutionCleared event.
 */
typedef struct estimator_staPollutionClearedEvent_t {
    /// Address of the STA for which pollution was cleared.
    struct ether_addr addr;
} estimator_staPollutionClearedEvent_t;

/**
 * @brief The format of the estimator_event_rcpiTypeChanged event.
 */
typedef struct estimator_rcpiTypeChangedEvent_t {
   /// Addr of STA whose RcpiType value is changed from 0 to 1
    struct ether_addr addr;

    /// rcpiTypeChanged value
    u_int8_t rcpiTypeChanged;
} estimator_rcpiTypeChangedEvent_t;

/**
 * @brief The format of the estimator_event_nonServingMetricsComplete event.
 */
typedef struct estimator_nonServingMetricsCompleteEvent_t {
    // The MAC address of the STA
    struct ether_addr staAddr;

    // Channel on which metrics are measured
    lbd_channelId_t channel;

    u_int16_t freq;
} estimator_nonServingMetricsCompleteEvent_t;

typedef ieee1905StaTrafficStats_t estimator_staTrafficStats_t;

typedef struct estimator_staTputEstCompleteEvent_t {
    // The MAC address of the STA
    struct ether_addr staAddr;
} estimator_staTputEstCompleteEvent_t;

/**
 * @brief Function callback type that other modules can register to be
 *        informed when data metrics can be measured again for a given entry.
 *
 * The callback occurs after the entry has been updated.
 *
 * @param [in] handle  the entry that was updated
 * @param [in] cookie  the value provided by the caller when the observer
 *                     callback function was registered
 */
typedef void (*estimator_staDataMetricsAllowedObserverCB)(
        stadbEntry_handle_t handle, void *cookie);

/**
 * @brief Initialize the estimator module.
 *
 * @return LBD_OK on success; otherwise LBD_NOK
 */
LBD_STATUS estimator_init(void);

/**
 * @brief Deinitialize the station monitor module
 *
 * @return LBD_OK on success; otherwise LBD_NOK
 */
LBD_STATUS estimator_fini(void);

/**
 * @brief Take the serving channel uplink RSSI and estimate the non-serving
 *        channels if necessary.
 *
 * The serving channel RSSI is assumed to be valid and recent. The uplink
 * RSSI will only be updated if it is not already valid based on probe
 * request measurements.
 *
 * @param [in] handle  the entry to update
 *
 * @return LBD_OK on success; otherwise LBD_NOK
 */
LBD_STATUS estimator_estimateNonServingUplinkRSSI(stadbEntry_handle_t handle);

/**
 * @brief Retrieve the consecutive 11k failure count.
 *
 * @param [in] handle  the handle of the STA for which to perform the estimate
 *
 * @return LBD_TRUE if max consecutive 11k failure count is reached
 *                  else return LBD_FALSE.
 */
LBD_BOOL estimator_is11kUnfriendly(stadbEntry_handle_t handle);

/**
 * @brief Compute capacity and airtime information for the STA on both the
 *        serving and non-serving channels.
 *
 * This will result in the entry's serving channel full capacity, last data rate
 * and airtime information being updated. On the non-serving channel, an
 * estimated capacity and airtime will be stored. Once both of these are
 * complete, a estimator_event_staDataMetricsComplete will be generated.
 *
 * @param [in] handle  the handle of the STA for which to perform the estimate
 * @param [in] trigger  the trigger of capacity and airtime estimation
 *
 * @return LBD_OK on success; otherwise LBD_NOK
 */
LBD_STATUS estimator_estimateSTADataMetrics(stadbEntry_handle_t handle,
                                            steerexec_reason_e trigger);

/**
 * @brief Start monitoring the backhaul station activity via the packet
 *        TX/RX count metrics.
 *
 * @return LBD_OK on success; otherwise LBD_NOK
 */
LBD_STATUS estimator_enableBackhaulStationActivityMonitoring(void);

/**
 * @brief Stop the monitoring of backhaul station activity via the packet
 *        TX/RX count metrics.
 *
 * @return LBD_OK on success; otherwise LBD_NOK
 */
LBD_STATUS estimator_disableBackhaulStationActivityMonitoring(void);

/**
 * @brief Measure downlink RSSI for a STA without triggering any steering
 *        or 11k throttling logic.
 *
 * This should only be called to request metrics for non-client devices (in
 * other words, STA interfaces on access points). For client devices, see
 * estimator_estimateSTADataMetrics above.
 *
 * @param [in] entry  the staDB handle of the STA for which to request
 *                    downlink RSSI
 * @param [in] bssStats  the stats handle of the serving BSS for the
 *                       given STA
 * @param [in] servingBSS  the serving BSS for the given STA
 * @param [in] numChannels  the number of channels in the channel list
 * @param [in] channelList  the channels for which to request downlink
 *                          RSSI on
 * @param [in] useBeaconTable  whether to use the beacon table measumurement
 *                             mode
 *
 * @return LBD_OK if the request succeeds; otherwise return LBD_NOK
 */
LBD_STATUS estimator_requestIndDownlinkRSSI(stadbEntry_handle_t entry,
                                            stadbEntry_bssStatsHandle_t bssStats,
                                            const lbd_bssInfo_t *servingBSS,
                                            size_t numChannels,
                                            const lbd_channelId_t *channelList,
                                            const uint16_t *freqList,
                                            LBD_BOOL useBeaconTable);

/**
 * @brief Record the STA full capacity values.
 *
 * This will result in the entry's capacity values being updated along with
 * any internal state estimator needs.
 *
 * @param [in] entry  the handle of the STA to update
 * @param [in] bssStats  the entry for which to update the capacity values
 * @param [in] ulCap  the uplink full capacity
 * @param [in] dlCap  the downlink full capacity
 *
 * @return LBD_OK on success; otherwise LBD_NOK
 */
LBD_STATUS estimator_handleSTAFullCapacities(stadbEntry_handle_t entry,
                                             stadbEntry_bssStatsHandle_t bssStats,
                                             lbd_linkCapacity_t ulCap,
                                             lbd_linkCapacity_t dlCap);

/**
 * @brief Compute the throughput and store the traffic stats for the STA.
 *
 * This will result in the entry's data rate and the packet stats of the
 * STA's estimate state being updated.
 *
 * @param [in] entry  the handle of the STA for which to perform the estimate
 * @param [in] apId  the ID of the AP that sends the mssage
 * @param [in] stats  latest received traffic stats for the STA
 *
 * @return LBD_OK on success; otherwise LBD_NOK
 */
LBD_STATUS estimator_handleSTATrafficStats(stadbEntry_handle_t entry,
                                           lbd_apId_t apId,
                                           const estimator_staTrafficStats_t *stats);

/**
 * @brief Get the traffic stats for the STA.
 *
 * @param [in] entry  the handle of the STA for which to perform the estimate
 * @param [in] stats  return traffic stats for the STA
 *
 * @return LBD_OK on success; otherwise LBD_NOK
 */
LBD_STATUS estimator_getSTATrafficStats(stadbEntry_handle_t entry,
                                        estimator_staTrafficStats_t *stats);

/**
 * @brief Store the traffic stats for the STA.
 *
 * @param [in] entry  the handle of the STA for which to perform the estimate
 * @param [in] stats  store traffic stats for the STA
 *
 * @return LBD_OK on success; otherwise LBD_NOK
 */
LBD_STATUS estimator_storeSTATrafficStatsMe(stadbEntry_handle_t entry,
                                            const estimator_staTrafficStats_t *stats);

/**
 * @brief Convert RSSI from dB (SNR) to dBm (RCPI)
 *
 * @param [in] entry  the handle of the STA
 * @param [in] rssi  rssi in dB
 *
 * @return RSSI value in dBm
 */
int8_t estimator_convertRSSIFromDbToDbm(stadbEntry_handle_t entry, lbd_rssi_t rssi);

/**
 * @brief Convert RSSI from dBm (RCPI) to dB (SNR)
 *
 * @param [in] entry  the handle of the STA
 * @param [in] rssi  rssi in dBm
 *
 * @return RSSI value in dB
 */
lbd_rssi_t estimator_convertRSSIFromDbmToDb(stadbEntry_handle_t entry, int8_t rssi);

/**
 * @brief Estimate the airtime of each STA active on the given channel that
 *        is a candidate for active steering.
 *
 * This will result in each entry's full capacity, last data rate, and airtime
 * information being updated. Once this is complete, an
 * estimator_event_perSTAAirtimeComplete event will be generated.
 *
 * @param [in] channelId  the channel on which to do the estimates
 * @param [in] apId  the Id of the AP which this estimate is for
 *
 * @return LBD_OK on success; otherwise LBD_NOK
 */
LBD_STATUS estimator_estimatePerSTAAirtimeOnChannel(lbd_apId_t apId,
                                                    lbd_channelId_t channelId,
                                                    u_int16_t freq);

/**
 * @brief Estimate the achievable TCP throughput (with 100% medium
 *        availability) for a given band and PHY rate.
 *
 * @param [in] band  the band for which to estimate the capacity
 * @param [in] phyRate  the estimated PHY rate for the link
 *
 * @return the estimated TCP throughput
 */
lbd_linkCapacity_t estimator_estimateTCPFullCapacity(wlanif_band_e band,
                                                     lbd_linkCapacity_t phyRate);

/**
 * @brief Register a function to get called back when an entry is now
 *        eligible again for an estimate of its data metrics.
 *
 * In other words, when the callback occurs,
 * estimator_estimateSTADataMetrics() is expected to succeed.
 *
 * @param [in] callback  the callback function to invoke
 * @param [in] cookie  the parameter to pass to the callback function
 *
 * @return LBD_OK on success; otherwise LBD_NOK
 */
LBD_STATUS estimator_registerSTADataMetricsAllowedObserver(
        estimator_staDataMetricsAllowedObserverCB callback, void *cookie);

/**
 * @brief Unregister the observer callback function.
 *
 * @param [in] callback  the callback function to unregister
 * @param [in] cookie  the parameter for the callback provided when
 *                     registering
 *
 * @return LBD_OK on success; otherwise LBD_NOK
 */
LBD_STATUS estimator_unregisterSTADataMetricsAllowedObserver(
        estimator_staDataMetricsAllowedObserverCB callback, void *cookie);

/**
 * @brief Make a  decision for a legacy client in multi AP setup to implement SON based
 * monitoring or mapService based implementation
 *
 * @pre entry is legacy and associated
 *
 * @param [in] entry  the STA that needs to be checked
 * @return LBD_OK on success ; otherwise LBD_NOK
 */
LBD_STATUS estimator_prepareSTAForLegacySteerMetrics(stadbEntry_handle_t entry);

/**
 * @brief  Estimate the downlink RCPI from uplink RSSI , Phy Rate from estimated RCPI and
 *         Air Time for all the BSSes and store the values back if applicable based on the
 *         conditions(RCPI validity/old measurement).
 *
 * @pre STA entry is legacy or 11k Unfriendly, uplink RSSI is available
 *
 * @param [in] handle the STA being handled to estimate the metrics
 *
 * @return LBD_OK if iteration over BSSes goes through properly ,
 *         LBD_NOK otherwise
 */
LBD_STATUS estimator_estimateAndStoreLegacySTAMetrics(stadbEntry_handle_t handle);

/*
 * @brief Function to abort the the collection of non serving legacy metrics
 *
 * @param [in] entry STA handle
 *
 * @return LBD_OK if collection of metrics is allowed; otherwise LBD_NOK
 */
LBD_STATUS estimator_abortLegacySteerMetrics(stadbEntry_handle_t entry);

/*
 * @brief Function to generate the event when collection of non serving metrics
 *        is complete
 *
 * @param [in] staAddr STA MAC address
 * @param [in] channel Channel on which metrics have been collected
 */
void estimator_createNonServingMetricsCompleteEvent(const struct ether_addr *staAddr,
                                                    u_int8_t channel);

// ====================================================================
// Constants needed by test cases
// ====================================================================

// These need not be exposed but it is useful to do so for unit tests to
// avoid duplicating the strings.

#define ESTIMATOR_AGE_LIMIT_KEY                    "AgeLimit"
#define ESTIMATOR_RSSI_DIFF_EST_W5_FROM_W2_KEY     "RSSIDiff_EstW5FromW2"
#define ESTIMATOR_RSSI_DIFF_EST_W2_FROM_W5_KEY     "RSSIDiff_EstW2FromW5"
#define ESTIMATOR_RSSI_DIFF_EST_W6_FROM_W2_KEY     "RSSIDiff_EstW6FromW2"
#define ESTIMATOR_RSSI_DIFF_EST_W2_FROM_W6_KEY     "RSSIDiff_EstW2FromW6"
#define ESTIMATOR_RSSI_DIFF_EST_W6_FROM_W5_KEY     "RSSIDiff_EstW6FromW5"
#define ESTIMATOR_RSSI_DIFF_EST_W5_FROM_W6_KEY     "RSSIDiff_EstW5FromW6"
#define ESTIMATOR_PROBE_COUNT_THRESHOLD_KEY        "ProbeCountThreshold"
#define ESTIMATOR_STATS_SAMPLE_INTERVAL_KEY        "StatsSampleInterval"
#define ESTIMATOR_BACKHAUL_STA_STATS_SAMPLE_INTERVAL_KEY  "BackhaulStationStatsSampleInterval"
#define ESTIMATOR_MAX_11K_RESPONSE_TIME_KEY        "Max11kResponseTime"
#define ESTIMATOR_MAX_11K_UNFRIENDLY_KEY           "Max11kUnfriendly"
#define ESTIMATOR_11K_PROHIBIT_TIME_SHORT_KEY      "11kProhibitTimeShort"
#define ESTIMATOR_11K_PROHIBIT_TIME_LONG_KEY       "11kProhibitTimeLong"
#define ESTIMATOR_DELAYED_11K_REQUEST_TIMER        "Delayed11kRequesttimer"
#define ESTIMATOR_LOW_PHY_RATE_THRESHOLD_KEY       "LowPhyRateThreshold"
#define ESTIMATOR_HIGH_PHY_RATE_THRESHOLD_W2_KEY   "HighPhyRateThreshold_W2"
#define ESTIMATOR_HIGH_PHY_RATE_THRESHOLD_W5_KEY   "HighPhyRateThreshold_W5"
#define ESTIMATOR_HIGH_PHY_RATE_THRESHOLD_W6_KEY   "HighPhyRateThreshold_W6"
#define ESTIMATOR_SCALING_FACTOR_LOW_KEY           "PhyRateScalingFactorLow"
#define ESTIMATOR_SCALING_FACTOR_MEDIUM_KEY        "PhyRateScalingFactorMedium"
#define ESTIMATOR_SCALING_FACTOR_HIGH_KEY          "PhyRateScalingFactorHigh"
#define ESTIMATOR_SCALING_FACTOR_TCP_KEY           "PhyRateScalingFactorTCP"
#define ESTIMATOR_ENABLE_CONTINUOUS_THROUGHPUT_KEY "EnableContinuousThroughput"
#define ESTIMATOR_MAX_POLLUTION_TIME_KEY           "MaxPollutionTime"
#define ESTIMATOR_FAST_POLLUTION_BUFSIZE_KEY       "FastPollutionDetectBufSize"
#define ESTIMATOR_NORMAL_POLLUTION_BUFSIZE_KEY     "NormalPollutionDetectBufSize"
#define ESTIMATOR_POLLUTION_DETECT_THRESHOLD_KEY   "PollutionDetectThreshold"
#define ESTIMATOR_POLLUTION_CLEAR_THRESHOLD_KEY    "PollutionClearThreshold"
#define ESTIMATOR_INTERFERENCE_AGE_LIMIT_KEY       "InterferenceAgeLimit"
#define ESTIMATOR_IAS_LOW_RSSI_THRESHOLD_KEY       "IASLowRSSIThreshold"
#define ESTIMATOR_IAS_MAX_RATE_FACTOR_KEY          "IASMaxRateFactor"
#define ESTIMATOR_IAS_MIN_DELTA_BYTES_KEY          "IASMinDeltaBytes"
#define ESTIMATOR_IAS_MIN_DELTA_PACKETS_KEY        "IASMinDeltaPackets"
#define ESTIMATOR_IAS_ENABLE_SINGLE_BAND_DETECT_KEY "IASEnableSingleBandDetect"
#define ESTIMATOR_ACT_DETECT_MIN_INTERVAL_KEY      "ActDetectMinInterval"
#define ESTIMATOR_ACT_DETECT_MIN_PKT_PER_SEC_KEY   "ActDetectMinPktPerSec"
#define ESTIMATOR_BACKHAUL_ACT_DETECT_MIN_PKT_PER_SEC_KEY  "BackhaulActDetectMinPktPerSec"
#define ESTIMATOR_INTERFERENCE_DETECTION_ENABLE_W2 "InterferenceDetectionEnable_W2"
#define ESTIMATOR_INTERFERENCE_DETECTION_ENABLE_W5 "InterferenceDetectionEnable_W5"
#define ESTIMATOR_INTERFERENCE_DETECTION_ENABLE_W6 "InterferenceDetectionEnable_W6"
#define ESTIMATOR_MAX_STEERING_RETRY_COUNT_KEY     "APSteerMaxRetryCount"
#define ESTIMATOR_RCPI_11K_COMPLIANT_DETECTION_THRESHOLD  "Rcpi11kCompliantDetectionThreshold"
#define ESTIMATOR_RCPI_11K_NONCOMPLIANT_DETECTION_THRESHOLD  "Rcpi11kNonCompliantDetectionThreshold"
#define ESTIMATOR_RCPI_TYPE_CLASSIFICATION_ENABLE  "EnableRcpiTypeClassification"

#define ESTIMATOR_IAS_CURVE_24G_20M_1SS "IASCurve_24G_20M_1SS"
#define ESTIMATOR_IAS_CURVE_24G_20M_2SS "IASCurve_24G_20M_2SS"
#define ESTIMATOR_IAS_CURVE_5G_40M_1SS "IASCurve_5G_40M_1SS"
#define ESTIMATOR_IAS_CURVE_5G_40M_2SS "IASCurve_5G_40M_2SS"
#define ESTIMATOR_IAS_CURVE_5G_80M_1SS "IASCurve_5G_80M_1SS"
#define ESTIMATOR_IAS_CURVE_5G_80M_2SS "IASCurve_5G_80M_2SS"

#define ESTIMATOR_CURVE_COEF_D0(curveType) curveType "_d0"
#define ESTIMATOR_CURVE_COEF_RSSI_D1(curveType) curveType "_rd1"
#define ESTIMATOR_CURVE_COEF_MCS_D1(curveType) curveType "_md1"
#define ESTIMATOR_CURVE_COEF_RSSI_D2(curveType) curveType "_rd2"
#define ESTIMATOR_CURVE_COEF_RSSI_MCS_D1(curveType) curveType "_rmd1"
#define ESTIMATOR_CURVE_COEF_MCS_D2(curveType) curveType "_md2"


#if defined(LBD_DBG_MENU) && defined(GMOCK_UNIT_TESTS)
struct cmdContext;

/**
 * @brief Request the status to be dumped for all STAs.
 *
 * @param [in] context  the output context
 * @param [in] cmd  the command in the debug CLI
 */
void estimatorMenuStatusHandler(struct cmdContext *context, const char *cmd);

/**
 * @brief Request a rate estimate for a STA.
 *
 * @param [in] context  the output context
 * @param [in] cmd  the command in the debug CLI
 */
void estimatorMenuRateHandler(struct cmdContext *context, const char *cmd);

/**
 * @brief Request an airtime estimate be done on a given channel.
 *
 * @param [in] context  the output context
 * @param [in] cmd  the command in the debug CLI
 */
void estimatorMenuAirtimeHandler(struct cmdContext *context, const char *cmd);

/**
 * @brief Turn on/off the debug mode for estimator (currently limited to
 *        the interference detection cases).
 *
 * @param [in] context  the output context
 * @param [in] cmd  the command in the debug CLI
 */
void estimatorMenuDebugHandler(struct cmdContext *context, const char *cmd);

/**
 * @brief Inject an event that a given STA is being impacted by interference
 *        or not.
 *
 * @param [in] context  the output context
 * @param [in] cmd  the command in the debug CLI
 */
void estimatorMenuInterferenceDetectedHandler(struct cmdContext *context,
                                              const char *cmd);

/**
 * @brief Inject fake statistics to evaluate interference
 *
 * @param [in] context  the output context
 * @param [in] cmd  the command in the debug CLI
 */
void estimatorMenuInterferenceStatsHandler(struct cmdContext *context,
                                           const char *cmd);

/**
 * @brief Trigger diaglog from the debug CLI
 *
 * @param [in] context  the output context
 * @param [in] cmd  the command in the debug CLI
 */
void estimatorMenuDiaglogHandler(struct cmdContext *context, const char *cmd);

#endif /* LBD_DBG_MENU && GMOCK_UNIT_TESTS */

#if defined(__cplusplus)
}
#endif

#endif // estimator__h

